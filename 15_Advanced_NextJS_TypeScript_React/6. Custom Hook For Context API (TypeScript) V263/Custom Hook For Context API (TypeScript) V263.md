## V263 Custom Hook For Context API (TypeScript)
Description: Why it's better to use a custom hook for consuming the context.


also here: 
Why use a Custom Hook for React Context API instead of useContext (+ TypeScript)
https://www.youtube.com/watch?v=I7dwJxGuGYQ

### Intro

One of the biggest mistakes that Junior React developers make is not using a custom Hook when they're using the Context API.

Let's see why we want to use a custom hook. 



### Context example

Let's say we have some logo components and if the user has set the theme to dark mode, we want to return the dark mode version of this logo, otherwise we want to return the light mode version.

`logo.tsx`
```tsx
import React from "react";

export default function Logo() {
  //if theme is dark mode, return dark mode logo...

  // if theme is light mode, return light mode logo...
  return <div>Logo</div>;
}
```


So in this `Logo()` component we need to know the theme and we can imagine, in other components we also need to know the theme and we don't want to do all that prop drilling. 

Instead we're going to create a `Context` for the theme. 

The theme is a very typical use case for the Context API in React. 

We will show the proper implementation using Context API in a Next.js project.

`theme-context.tsx`
```tsx
import React, { createContext, useState } from "react";

const ThemeContext = createContext(null);

export default function ThemeContextProvider({ children }) {
  const [theme, setTheme] = useState("light");

  return (
    <ThemeContext.Provider
      value={{
        theme,
        setTheme,
      }}
    >
      {children}
    </ThemeContext.Provider>  
  );
}
```


Typically you're going to have a separate folder with all your `/contexts/`

We can create a context like this `createContext()` and the initial value that we pass here is actually the value that we will get if we try to consume the context outside the provider component.

We can create a context like here `const ThemeContext = createContext(null)`

and then we can use that variable `ThemeContext` to make `.Provider` and then we specify the value that we want to pass to the consumers of this context

We're going to consume this context in the `Logo()` and we decide in `.Provider value={{` what we are actually passing through.

That is going to be an object with `theme` and `setTheme`.

The actual `theme` is what we're keeping track of here `const [theme, setTheme] = useState("light");`, initially it's going to be `"light"` 

### Wrap app with context

We've created our context, now we need to wrap the part of our app that needs access to this context.

We are  using Next.js, we have this `layout.tsx` file. This `RootLayout` is basically the root component of the whole React component tree, this is wrapping all the pages.

`layout.tsx` 
```tsx
import ThemeContextProvider from "@/contexts/theme-context"; // needed import
import "./global.css";
import { Inter } from "next/font/google"; 

const inter = Inter({ subsets: ["latin"] });

export const metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <head>
        <title>{metadata.title}</title>
        <meta name="description" content={metadata.description} />
      </head>
      <body className={inter.className}>
        <ThemeContextProvider>{children}</ThemeContextProvider>
      </body>
    </html>
  );
};
```

 Now with the theme we want to have this pretty high up in your react component tree, because a lot of components need access to it, so we might as well just wrap essentially our whole app with it. 
 
Here we can say `<ThemeContextProvider>` We import this component and just wrap everything (`{children}`) in here, the `{children}` here is going to be the page. It's going to be home page, "about" page. 

Next.js will substitute the children here essentially for whatever page we are on.

Every page now has access to this `<ThemeContextProvider>` provider component.


### Client component

When we do this `<ThemeContextProvider>{children}</ThemeContextProvider>`, we get an issue because we are using `useState` here (`theme-context.tsx`), which is only possible in client components.

(In Next.js, using `useState()` is possible only in a client components. This is because `useState()` is a React hook used to manage state in React components, and state is inherently a client-side concept.)


`theme-context.tsx` - `useState` causing error
```tsx
import React, { createContext, useState } from "react";

const ThemeContext = createContext(null);

export default function ThemeContextProvider({ children }) {
  const [theme, setTheme] = useState("light");

  return (
    <ThemeContext.Provider
      value={{
        theme,
        setTheme,
      }}
    >
      {children}
    </ThemeContext.Provider>  
  );
}
```


Let's quickly convert this Context Provider Component to a client's component. Now the error is gone. 

`theme-context.tsx`
```tsx
"use client";

import React, { createContext, useState } from "react";

export const ThemeContext = createContext(null);

export default function ThemeContextProvider({ children }) {
  const [theme, setTheme] = useState("light");

  return (
    <ThemeContext.Provider
      value={{
        theme,
        setTheme,
      }}
    >
      {children}
    </ThemeContext.Provider>  
  );
}
```


A very typical mistake here by the way is that people think that now because we made this Context Provider Component a client component, some people think that now everything here `<ThemeContextProvider>{children}</ThemeContextProvider>` becomes a client component and that's not true, because what we're doing here in the Provider Component is just getting the children `function ThemeContextProvider({ children }) {` and just passing through `{children} </ThemeContext.Provider>  `.

This Context Provider Component can be a client's component and everything in here ` <ThemeContextProvider>{children}</ThemeContextProvider>` can stay a server component. 

This is the right way of implementing the Context API in Next.js


### Consuming context (useContext)

Now every page has access to the Context and let's say we want to use it in `Logo()` here.
We need to make sure that `Logo()` is part of some page in Next.js.

`logo.tsx`
```tsx
import React from "react";

export default function Logo() {
  //if theme is dark mode, return dark mode logo...

  // if theme is light mode, return light mode logo...
  return <div>Logo</div>;
}
```

In the root of the `/app/` directory we also get the `page.tsx` file. This is for our home page. 

Let's just add the `<Logo />` component to the home page just so we can then consume the Context API. 

`page.tsx`
```tsx
import Logo from "@/components/logo";

export default function Home() {
  return (
    <main className="flex min-h-screen flex-col items-center justify-between p-24">
      <Logo />
    <main>  
  );
}
```

Now we can consume the Context API in this `Logo()`.

First part of Context API, provide the value, 

Second, we can consume the value. (now)

So we want to consume that context, we can use react `useContext()` to use Context Hook. 
Then React wants to know which Context, because we can have many different Contexts. 

`logo.tsx`
```tsx
import { ThemeContext } from "@/contexts/theme-context";
import React, { useContext } from "react";

export default function Logo() {
  const context = useContext(ThemeContext);
  //if theme is dark mode, return dark mode logo...

  // if theme is light mode, return light mode logo...
  return <div>Logo</div>;
}
```

We get an error here because we are using a client-side hook (`useContext`). 

This also needs to become a client component now. 

`logo.tsx`
```tsx
"use client";

import { ThemeContext } from "@/contexts/theme-context";
import React, { useContext } from "react";

export default function Logo() {
  const context = useContext(ThemeContext);
  //if theme is dark mode, return dark mode logo...

  // if theme is light mode, return light mode logo...
  return <div>Logo</div>;
}
```



### First problem


The first problem with `useContext()` here is that we need to carry around this variable here
`import { ThemeContext } from "@/contexts/theme-context";`

In every component that we want to use this `ThemeContext` we have to carry around this `ThemeContext`,  import it, specify manually and that's annoying. 



### Second problem

Second problem with what we're doing here now. 

Let's say we actually want to use the `context` so we have the `theme` 

`logo.tsx`
```tsx
"use client";

import { ThemeContext } from "@/contexts/theme-context";
import React, { useContext } from "react";

export default function Logo() {
  const context = useContext(ThemeContext);
  //context.theme // <- we get an issue on that
  
  //if theme is dark mode, return dark mode logo...

  // if theme is light mode, return light mode logo...
  return <div>Logo</div>;
}
```

We have we're passing through the `theme` and `setTheme`.

We should be able to use `context.theme` but if we do that we're going to get an issue `"'context' is possibly 'null'"`. 

Now typically we actually just destructure it immediately.
`const { theme, setTheme } = useContext(ThemeContext);`

This is what we want to get from our context. 

We are consuming our contacts like this usually.

But this doesn't work out of the box, we actually get an issue here `const { theme, setTheme } = useContext(ThemeContext);`, intellisense is saying `"Property 'theme' does not exist on type 'null'"`, and the same for set theme.

`logo.tsx`
```tsx
"use client";

import { ThemeContext } from "@/contexts/theme-context";
import React, { useContext } from "react";

export default function Logo() {
  const { theme, setTheme } = useContext(ThemeContext); // <- we get an issue on that
  //context.theme // <- we get an issue on that
  
  //if theme is dark mode, return dark mode logo...

  // if theme is light mode, return light mode logo...
  return <div>Logo</div>;
}
```

and this is coming from the fact that we have specified `null` here `theme-context.tsx` -
`export const ThemeContext = createContext(null);` , we have specified `null` as the value that we should if we try to consume the Context outside the Context Provider Component. 

Here here if we would add the `<Logo />` like this, the `<Logo />` is outside the Context Provider 

`layout.tsx` 
```tsx
import ThemeContextProvider from "@/contexts/theme-context"; // needed import
import "./global.css";
import { Inter } from "next/font/google"; 

const inter = Inter({ subsets: ["latin"] });

export const metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <head>
        <title>{metadata.title}</title>
        <meta name="description" content={metadata.description} />
      </head>
      <body className={inter.className}>
        <Logo />{/* This Logo component is outside the Context Provider*/}
        <ThemeContextProvider>{children}</ThemeContextProvider>
      </body>
    </html>
  );
};
```

Here when we try to consume the Context `{ theme, setTheme }` technically it could be `null`

`logo.tsx`
```tsx
"use client";

import { ThemeContext } from "@/contexts/theme-context";
import React, { useContext } from "react";

export default function Logo() {
  const { theme, setTheme } = useContext(ThemeContext); // <- we get an issue on that
  //context.theme // <- we get an issue on that
  
  //if theme is dark mode, return dark mode logo...

  // if theme is light mode, return light mode logo...
  return <div>Logo</div>;
}
```

`Logo()` component could be an instance where we are actually using it outside the Provider Component. 


### Check for null

Here we cannot just start using `theme` and `setTheme` - `const { theme, setTheme } = useContext(ThemeContext);`. We have to first check that it's not `null`. 
If this context is `null` we want to let's say `throw` an `Error()` so we can immediately solve it. The `Error` produces a message. Then we can start using the `theme` and `setTheme` safely. 

`logo.tsx`
```tsx
"use client";

import { ThemeContext } from "@/contexts/theme-context";
import React, { useContext } from "react";

export default function Logo() {
  const context = useContext(ThemeContext); // <- we get an issue on that
  if (!context) {
    throw new Error("Theme context should be used within ThemeContextProvider");
  }
  //context.theme // <- we get an issue on that
  
  //if theme is dark mode, return dark mode logo...

  // if theme is light mode, return light mode logo...
  return <div>Logo</div>;
}
```


Problem when we're just using the context like this `useContext(ThemeContext)` is we have to carry around this variable `ThemeContext` which is annoying. 

Second problem is we have to check for that `null` value every time before we can use it.



### Custom hook

The solution for this is actually a custom hook. 

What could be done is whenever we create a Context in the same file here we also can create a custom hook for consuming the Context. 

`theme-context.tsx`
```tsx
"use client";

import React, { createContext, useState } from "react";

export const ThemeContext = createContext(null);

export default function ThemeContextProvider({ children }) {
  const [theme, setTheme] = useState("light");

  return (
    <ThemeContext.Provider
      value={{
        theme,
        setTheme,
      }}
    >
      {children}
    </ThemeContext.Provider>  
  );
}

function useThemeContext() {

}
```

Let's call that function `useThemeContext()`, the function name starts with `use` because we are going to use a React hook in there. The convention is then that we put the `use` word in front of the functions so that it's clear that we're using a react hook in there. 

So then here in `Logo()` we're not going to do this null check like this `if (!context) {` or carry around the variable like this `import { ThemeContext } from "@/contexts/theme-context";`.

`logo.tsx`
```tsx
"use client";

import { ThemeContext } from "@/contexts/theme-context";
import React, { useContext } from "react";

export default function Logo() {
  const context = useContext(ThemeContext); // <- we get an issue on that
  if (!context) {
    throw new Error("Theme context should be used within ThemeContextProvider");
  }
  //context.theme // <- we get an issue on that
  
  //if theme is dark mode, return dark mode logo...

  // if theme is light mode, return light mode logo...
  return <div>Logo</div>;
}
```


We can already do that in our reusable function `e.g. useThemeContext()`. 

Here we can simply try to consume that Context. 


We don't want to check for undefined alone `if (context === undefined) {`, we just want to do it like this `if (!context) {` and if it is not `null` we can say `"useThemeContext must be used within a ThemeContextProvider"`.

`theme-context.tsx`
```tsx
"use client";

import React, { createContext, useState } from "react";

export const ThemeContext = createContext(null);

export default function ThemeContextProvider({ children }) {
  const [theme, setTheme] = useState("light");

  return (
    <ThemeContext.Provider
      value={{
        theme,
        setTheme,
      }}
    >
      {children}
    </ThemeContext.Provider>  
  );
}

export function useThemeContext() {
  const context = useContext(ThemeContext);
  if (!context){
    throw new Error(
      "useThemeContext must be used within a ThemeContextProvider"
    );
  }
  return context;
}
```

If we try \using it outside like here (placement of `<Logo />`), an error will be thrown `throw new Error("useThemeContext must be used within a ThemeContextProvider");` so we can immediately fix, otherwise we can just return the `context`.

layout.tsx fragement
```tsx
      <body className={inter.className}>
        <Logo />{/* This Logo component is outside the Context Provider*/}
        <ThemeContextProvider>{children}</ThemeContextProvider>
      </body>
```


### Consume context

Now we want to consume the context it in some component e.g. `Logo()`. We can just use that hook.

Now we can immediately destructure it `{ theme, setTheme }` and we can just use our custom hook `useThemeContext()`.

`logo.tsx`
```tsx
"use client";

//import { ThemeContext } from "@/contexts/theme-context";
import { useThemeContext } from "@/contexts/theme-context";
//import React, { useContext } from "react";
import React from "react";

export default function Logo() {
  const { theme, setTheme } = useThemeContext(); // <- we get an issue on that
  
  //if theme is dark mode, return dark mode logo...

  // if theme is light mode, return light mode logo...
  return <div>Logo</div>;
}
```

Now we can see we don't have to carry around some annoying variable every time (`import { ThemeContext }`) and we also don't have to check for `null` value (`if (!context){` in `logo.tsx`).

It's also immediately clear from this hook name (e.g. `useThemeContext()`) what context we are using. The problems are now abstracted away into a custom hook.

### Context API TypeScript typing

We are using TypeScript here and we haven't properly typed everything here.

Let's do that for completeness sake. 

Let's just follow the red squiggly lines.

#### Component props type

Here we have `({ children })` to type component props, we separate it out into a separate type. Then we will just type that at the top of the file. There will just be an object with children and `ReactNode`.

`theme-context.tsx`
```tsx
"use client";

import React, { createContext, useState } from "react";

type ThemeContextProviderProps = {
  children: React.ReactNode;
};


export const ThemeContext = createContext(null);

export default function ThemeContextProvider({ children }) {
  const [theme, setTheme] = useState("light");

  return (
    <ThemeContext.Provider
      value={{
        theme,
        setTheme,
      }}
    >
      {children}
    </ThemeContext.Provider>  
  );
}

export function useThemeContext() {
  const context = useContext(ThemeContext);
  if (!context){
    throw new Error(
      "useThemeContext must be used within a ThemeContextProvider"
    );
  }
  return context;
}
```


#### Context type

Second red squiggly line here is for `value`, intellisense is saying something about value is not assignable to type null, 

We're saying the values should be in object with a `theme` and `setTheme` but we have specified this `null` value  when we created the context `createContext(null);` and TypeScript has inferred from that that this context is going to be some `null` value. 

So then when we try to pass an object `value={{ theme, setTheme, }}` it's telling us that we are trying to assign something that should be `null` value.

So here when we create the context we need to properly specify what this context's  shape is going to be.

Let's just call that type of `ThemeContext` which we can then specify above.
This `ThemeContext` will be an object with `theme` that is going to be `string`;
and then also `setTheme` which will be a React setter function here. Now we don't know the type of the topper hat and we get a great suggestion here from Copilot which is actually true in this case, but let's say we are not using Copilot or Copilot gives a different suggestion. We can just hover the `setTheme` (intellisense), TypeScript will tell us what type this is `"const setTheme: React.Dispatch<React.SetStateAction<string>>"`.

`theme-context.tsx`
```tsx
"use client";

import React, { createContext, useState } from "react";

type ThemeContextProviderProps = {
  children: React.ReactNode;
};

type ThemeContext = {
  theme: string;
  setTheme: React.Dispatch<React.SetStateAction<string>>; 
}

export const ThemeContext = createContext<ThemeContext>(null);

export default function ThemeContextProvider({ children }) {
  const [theme, setTheme] = useState("light");

  return (
    <ThemeContext.Provider
      value={{
        theme,
        setTheme,
      }}
    >
      {children}
    </ThemeContext.Provider>  
  );
}

export function useThemeContext() {
  const context = useContext(ThemeContext);
  if (!context){
    throw new Error(
      "useThemeContext must be used within a ThemeContextProvider"
    );
  }
  return context;
}
```

Now we got red squiggly line under `null` - `createContext<ThemeContext>(null)` because now we're telling TypeScript this context is going to be of type `ThemeContext` which has a `theme` and `setTheme` and suddenly we're passing `null` here. 

So it's telling us "why you're passing `null` here this is not in the type that you just specified in `ThemeContext`". 

What we can do here is we can say this is going to be of type `ThemeContext | null`, because it could be `null` if we try to use it outside that Context Provider. In that case it's going to be `null`, otherwise it will be this `ThemeContext`. 

#### 'Light' | 'Dark' type

Now we can be a little bit more specific about this `theme` ( `ThemeContext = { theme: string;`) it's not going to be of any `string`, we can be more specific than that. It's going to specifically be only `dark` or `light`, so not any `string`. 

`theme-context.tsx`
```tsx
"use client";

import React, { createContext, useState } from "react";

type ThemeContextProviderProps = {
  children: React.ReactNode;
};

type ThemeContext = {
  //theme: string;
  theme: 'dark' | 'light';
  setTheme: React.Dispatch<React.SetStateAction<string>>; 
}

export const ThemeContext = createContext<ThemeContext>(null);

export default function ThemeContextProvider({ children }) {
  const [theme, setTheme] = useState("light");

  return (
    <ThemeContext.Provider
      value={{
        theme,
        setTheme,
      }}
    >
      {children}
    </ThemeContext.Provider>  
  );
}

export function useThemeContext() {
  const context = useContext(ThemeContext);
  if (!context){
    throw new Error(
      "useThemeContext must be used within a ThemeContextProvider"
    );
  }
  return context;
}
```


Then we get the next red squiggly line which is here `value={{ theme,`, "Type string is not assignable to type dark or light". So now the problem is we are trying to use a `theme` in our `value` here and it thinks that `theme` can be any `string`. 

Here we have just specified it's going to be either `dark or light`, but this `theme` variable here has been typed as `string` -> `const [theme, setTheme] = useState("light");`

TypeScript has inferred from this string `"light"`, that this is going to be of any `string`. 

This is a very tricky one.

Here with `useState` we can also specify what type it's going to be (`useState<>`). We can say that's going to be either `dark` or `light`. 

When we do that we can see the red squiggly line here is removed.

`theme-context.tsx`
```tsx
"use client";

import React, { createContext, useState } from "react";

type ThemeContextProviderProps = {
  children: React.ReactNode;
};

type ThemeContext = {
  //theme: string;
  theme: 'dark' | 'light';
  setTheme: React.Dispatch<React.SetStateAction<string>>; 
}

export const ThemeContext = createContext<ThemeContext>(null);

export default function ThemeContextProvider({ children }) {
  const [theme, setTheme] = useState<'dark' | 'light'>("light");

  return (
    <ThemeContext.Provider
      value={{
        theme,
        setTheme,
      }}
    >
      {children}
    </ThemeContext.Provider>  
  );
}

export function useThemeContext() {
  const context = useContext(ThemeContext);
  if (!context){
    throw new Error(
      "useThemeContext must be used within a ThemeContextProvider"
    );
  }
  return context;
}
```


#### Theme type

Now we are duplicating ourselves with `'dark' | 'light'`, so we could also extract this out into its own type. We can just call that `type Theme` and this is going to be this union type. We can just specify the `Theme` separately like this and then we can just use that type. 

`theme-context.tsx`
```tsx
"use client";

import React, { createContext, useState } from "react";

type ThemeContextProviderProps = {
  children: React.ReactNode;
};

type Theme = 'dark' | 'light';

type ThemeContext = {
  //theme: string;
  //theme: 'dark' | 'light';
  theme: Theme;
  setTheme: React.Dispatch<React.SetStateAction<string>>; 
}

export const ThemeContext = createContext<ThemeContext>(null);

export default function ThemeContextProvider({ children }) {
  //const [theme, setTheme] = useState<'dark' | 'light'>("light");
  const [theme, setTheme] = useState<Theme>("light");

  return (
    <ThemeContext.Provider
      value={{
        theme,
        setTheme,
      }}
    >
      {children}
    </ThemeContext.Provider>  
  );
}

export function useThemeContext() {
  const context = useContext(ThemeContext);
  if (!context){
    throw new Error(
      "useThemeContext must be used within a ThemeContextProvider"
    );
  }
  return context;
}
```


#### setTheme type 

Then we have one more red squiggly line here  `value={{ (...), setTheme, }}` 

Let's take a look, Intellisense is telling 
```js
Type 'Dispatch<SetStateAction<Theme>>' is not assignable to type 'Dispatch<SetStateAction<string>>'.
Type 'SetStateAction<string>' is not assignable to type 'SetStateAction<Theme>'.
Type 'string' is not assignable to type 'SetStateAction<Theme>'.
(property) setTHeme:
React.Dispatch<React.SetStateAction<string>>
```

and this is coming from here 

`theme-context.tsx` fragment
```tsx
type ThemeContext = {
  //theme: string;
  //theme: 'dark' | 'light';
  theme: Theme;
  setTheme: React.Dispatch<React.SetStateAction<string>>; // <
}
```

Here `setTheme: React.Dispatch<React.SetStateAction<string>>` we're basically allowing any string to be passed in when we call the setter function `setTheme:`. 

Well we can be more specific than that. We can now only pass in something that's of type `Theme`. Either the string `dark` or the string `light`. 

Now all of our red squiggly lines are gone and we solve that whole TypeScript issue. 



### Type alias vs Interface

As a side note by the way, this is also one of the reasons why we want to use the `type alias` and not `interface`

With interface we cannot assign a union type like this:
```tsx
// this is illegal, we cannot do this
interface Theme = 'dark' | 'light';
```

With `interface` we are always describing an object. 
With `type` alias we can describe an object but then also everything else, in this case the union type. 

